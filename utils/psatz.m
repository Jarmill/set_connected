function [p_out, cons, Gram] = psatz(p, X, order, vars, var_count)
%PSATZ Formulate polynomials and constraints for a psatz expression
%certificate of p>=0 over the support set X
%p can be a scalar or a symmetric matrix
%Author: Jared Miller, Dec 11, 2021
%  INPUT:
%   p:          polynomial (matrix) which should be nonnegative (PSD)
%   X:          support struct set with fields 'ineq' and 'eq'
%                   'ineq': vector of inequality constraints (each scalar)
%                   'eq':   vector of equality   constraints (each scalar)
%   order:      order of the relaxation
%   vars:       variables used in the problem
%   var_count:  symmetry structure (if scalar, then symmetric = [])
%               [symmetric;
%                standard]
%  OUTPUT:
%   p_out:      New Psatz expression
%   cons:       constraints generated by this psatz expression
%   Gram:       cell array of gram matrices as variables

%start out the outputs
p_out = p;
cons = [];

if nargin < 5
    var_count = length(vars);
end

if (length(var_count)==2) && (var_count(1)>0)
    %yes symmetry
    Gram = cell((1+length(X.ineq))*2, 1);
else
    %no symmetry
    Gram = cell((1+length(X.ineq)), 1);
end

%p is a q x q matrix
q = length(p);


N_ineq = length(X.ineq);

%get the moment matrices and degrees to use
order_list = zeros(N_ineq + 1, 1);
order_list(1) = order;
for i = 1:N_ineq
    order_list(i+1) = order -  ceil(degree(X.ineq(i))/2);
end
%ic: index of moment matrix in mom_out used by constraint
[order_unique, ia, index_order] = unique(order_list);
Norder = length(order_unique);


%cell(length(X.ineq)+1, 1)
%% generate a moment matrix for each unique degree
mom_degree = cell(length(order_unique), 1);
for i = 1:length(order_unique)
    mom_degree{i} = make_moments(var_count, order_unique(i));     
    mom_degree{i}.v_monom = recovermonoms(mom_degree{i}.monom_int, vars);
end


%% new for loop 
pop = [1; X.ineq];
for i = 1:length(pop)
    %current index to search
    ind_curr = index_order(i);           
    
    p_curr = pop(i);
    %perform reduction
    v_monom_curr = mom_degree{ind_curr}.v_monom;

    %yalmip breaks the ordering of monomials in the labeling. recovermonoms
    %sorts monomials according to the monomial table.
    
    vp_monom = p_curr*v_monom_curr;

    %polynomial matrices
    
    %there is probably a better way to do this using accumarray
    M_even_curr = vp_monom(mom_degree{ind_curr}.M_even);
    M_odd_curr = vp_monom(mom_degree{ind_curr}.M_odd);
    N_even_curr = mom_degree{ind_curr}.N_even;
    N_odd_curr = mom_degree{ind_curr}.N_odd;
    
   
    
    %define the gram matrices    
    
    %even Gram matrix
    G_even = sdpvar(q*N_even_curr, q*N_even_curr, 'symmetric');
%     putinar_curr = sum(G_even.*M_even_curr, 'all');
    putinar_curr = zeros(q, q, 'like', sdpvar);
    for qi = 1:q
        ind_i = N_even_curr *(qi-1) + (1:N_even_curr);
        for qj = 1:q
            ind_j = N_even_curr *(qj-1) + (1:N_even_curr);
            putinar_curr(qi, qj) = sum(G_even(ind_i, ind_j) .* M_even_curr, 'all');
        end
    end

    
    %odd Gram matrix
    if N_odd_curr
        %store the gram matrix first
        Gram{2*i-1} = G_even;
        cons = [cons; G_even >= 0];
        
%         G_odd  = sdpvar(N_odd_curr,  N_odd_curr,  'symmetric');
        for qi = 1:q
            ind_i = N_odd_curr *(qi-1) + (1:N_even_curr);
            for qj = 1:q
                ind_j = N_odd_curr *(qj-1) + (1:N_even_curr);
            putinar_curr(qi, qj) = putinar_curr(qi, qj) + sum(G_odd(ind_i, ind_j) .* M_odd_curr, 'all'); 
            end
        end
        Gram{2*i}   = G_odd;
        cons = [cons; G_odd >= 0];
    else
        Gram{i} = G_even;
        cons = [cons; G_even >= 0];
    end
    
    %update the outputs
    p_out = p_out - putinar_curr;
    
%     coeff = [coeff; reshape(G_even, [], 1); reshape(G_odd, [], 1)];
end



  
%put in equality constraints later. I've already taken out the order-2
%reduction.


%coefficient matching conditions on the putinar expression
[cpsatz, mpsatz] = coefficients(reshape(p_out, [], 1), vars);

cons = [cons; cpsatz==0];
end

